# Contract Testing Reference

**Location**: `skills/pact-testing-patterns/references/contract-testing.md`

**Purpose**: Comprehensive guide to contract testing, consumer-driven contracts, schema validation, and microservices integration testing.

**Used by**: pact-test-engineer agent when designing contract tests for distributed systems and microservices

**Related files**:
- `../SKILL.md` - Quick reference and decision tree
- `test-strategies.md` - Overall testing approaches
- `test-coverage.md` - Coverage metrics and analysis

---

## What is Contract Testing?

### Definition

**Contract Testing** is a testing methodology that verifies interactions between service boundaries in distributed systems. It validates that a provider (server/API) meets the expectations of its consumers (clients), ensuring that communication contracts are honored without requiring end-to-end integration tests.

**Key Concepts**:
- **Consumer**: The application that initiates a request (client, frontend, service A)
- **Provider**: The application that responds to a request (API, backend, service B)
- **Contract**: A formal agreement defining expected request/response interactions
- **Pact**: A specific contract file (JSON) generated by consumer tests

**Note**: This section refers to the Pact **testing framework**, which is distinct from the PACT **methodology** (Prepare, Architect, Code, Test) used in this skill library.

---

### Why Contract Testing?

**Problems with Traditional Integration Testing**:
- **Slow**: Requires spinning up multiple services, databases, message queues
- **Brittle**: Fails due to infrastructure issues unrelated to contract violations
- **Expensive**: Needs complex test environments, orchestration, and maintenance
- **Delayed Feedback**: Often only run in staging/pre-production environments

**Contract Testing Benefits**:
- **Fast**: Tests run in milliseconds (no real service dependencies)
- **Isolated**: Each service tested independently with mocked interactions
- **Early Detection**: Catch integration issues before deployment
- **API Evolution**: Safely evolve APIs with confidence in compatibility
- **Cross-Team Collaboration**: Contracts serve as living documentation

**When to Use Contract Testing**:
- Microservices architecture with multiple service dependencies
- Frontend applications consuming backend APIs
- Third-party API integrations
- Messaging systems (event-driven architectures)
- Mobile apps communicating with backend services

---

## Consumer-Driven Contracts (CDC)

### Philosophy

**Consumer-Driven Contract Testing (CDC)** is an approach where consumers define the contract by specifying their expectations of the provider. This inverts traditional provider-first API design.

**Traditional Approach**:
```
Provider defines API → Consumers adapt to API → Breaking changes affect all consumers
```

**Consumer-Driven Approach**:
```
Consumers define expectations → Provider implements to meet expectations → Changes driven by real needs
```

**Benefits**:
- **Focus on Usage**: Provider only implements what consumers actually need
- **Prevents Over-Engineering**: No unused API endpoints or fields
- **Safe Refactoring**: Provider can refactor as long as consumer expectations are met
- **Bilateral Testing**: Both consumer and provider have test suites

---

### CDC Workflow

**Step 1: Consumer Writes Tests**
```javascript
// Consumer test (frontend testing API expectations)
const { Pact } = require('@pact-foundation/pact');

describe('User API', () => {
  const provider = new Pact({
    consumer: 'UserUI',
    provider: 'UserAPI',
  });

  beforeAll(() => provider.setup());
  afterAll(() => provider.finalize());

  it('retrieves user by ID', async () => {
    // Define expected interaction
    await provider.addInteraction({
      state: 'user with ID 1 exists',
      uponReceiving: 'a request for user 1',
      withRequest: {
        method: 'GET',
        path: '/users/1',
        headers: { Accept: 'application/json' },
      },
      willRespondWith: {
        status: 200,
        headers: { 'Content-Type': 'application/json' },
        body: {
          id: 1,
          name: 'Alice',
          email: 'alice@example.com',
        },
      },
    });

    // Run consumer code against mock provider
    const response = await apiClient.getUser(1);

    expect(response.id).toBe(1);
    expect(response.name).toBe('Alice');
  });
});
```

**What Happens**:
1. Consumer test defines expected request/response
2. Pact creates mock provider that responds as expected
3. Consumer code runs against mock provider
4. Pact generates contract file (`UserUI-UserAPI.json`)

**Step 2: Publish Contract to Pact Broker**
```bash
# Consumer publishes contract after tests pass
pact-broker publish pacts/UserUI-UserAPI.json \
  --consumer-app-version=1.2.3 \
  --tag=main \
  --broker-base-url=https://pact-broker.example.com
```

**Step 3: Provider Verifies Contract**
```javascript
// Provider verification test (backend verifying it meets consumer expectations)
const { Verifier } = require('@pact-foundation/pact');

describe('Pact Verification', () => {
  it('validates the expectations of UserUI', () => {
    const opts = {
      provider: 'UserAPI',
      providerBaseUrl: 'http://localhost:3000',
      pactBrokerUrl: 'https://pact-broker.example.com',
      publishVerificationResult: true,
      providerVersion: '2.0.1',
      stateHandlers: {
        'user with ID 1 exists': async () => {
          // Setup: Insert test user into database
          await db.users.insert({ id: 1, name: 'Alice', email: 'alice@example.com' });
        },
      },
    };

    return new Verifier(opts).verifyProvider();
  });
});
```

**What Happens**:
1. Provider fetches contract from Pact Broker
2. For each interaction, provider sets up required state
3. Pact sends real HTTP request to provider
4. Provider response is validated against contract expectations
5. Verification result published to Pact Broker

**Step 4: Can-I-Deploy Check**
```bash
# Before deploying, check if all contracts are verified
pact-broker can-i-deploy \
  --pacticipant UserAPI \
  --version 2.0.1 \
  --to-environment production \
  --broker-base-url=https://pact-broker.example.com
```

**Output**:
```
Computer says yes \o/

CONSUMER       | C.VERSION | PROVIDER  | P.VERSION | SUCCESS? | RESULT
---------------|-----------|-----------|-----------|----------|--------
UserUI         | 1.2.3     | UserAPI   | 2.0.1     | true     | ✓ Verified
```

If verification fails, deployment is blocked until contracts are satisfied.

---

## Pact Framework Deep Dive

### Installation

**JavaScript/TypeScript**:
```bash
npm install --save-dev @pact-foundation/pact
```

**Python**:
```bash
pip install pact-python
```

**Java**:
```xml
<dependency>
  <groupId>au.com.dius.pact.consumer</groupId>
  <artifactId>junit5</artifactId>
  <version>4.6.13</version>
  <scope>test</scope>
</dependency>
```

---

### Consumer Test Patterns

#### Basic GET Request

```javascript
const { Pact } = require('@pact-foundation/pact');
const { like, eachLike } = require('@pact-foundation/pact').MatchersV3;

describe('Products API', () => {
  const provider = new Pact({
    consumer: 'ProductUI',
    provider: 'ProductAPI',
    port: 1234,
  });

  beforeAll(() => provider.setup());
  afterEach(() => provider.verify());
  afterAll(() => provider.finalize());

  it('retrieves all products', async () => {
    await provider.addInteraction({
      state: 'products exist',
      uponReceiving: 'a request for all products',
      withRequest: {
        method: 'GET',
        path: '/products',
      },
      willRespondWith: {
        status: 200,
        headers: { 'Content-Type': 'application/json' },
        body: eachLike({
          id: like(1),
          name: like('Product A'),
          price: like(29.99),
        }),
      },
    });

    const client = new ProductClient('http://localhost:1234');
    const products = await client.getProducts();

    expect(products.length).toBeGreaterThan(0);
    expect(products[0]).toHaveProperty('id');
    expect(products[0]).toHaveProperty('name');
  });
});
```

**Matchers**:
- `like(value)`: Matches type, not exact value (flexible)
- `eachLike(value)`: Matches array where each item matches pattern
- `regex(pattern, example)`: Matches regex pattern
- `term(pattern, example)`: Alias for regex

---

#### POST Request with Body

```javascript
it('creates a new user', async () => {
  await provider.addInteraction({
    state: 'no user with email test@example.com exists',
    uponReceiving: 'a request to create a user',
    withRequest: {
      method: 'POST',
      path: '/users',
      headers: { 'Content-Type': 'application/json' },
      body: {
        name: like('Bob'),
        email: regex(/\S+@\S+\.\S+/, 'test@example.com'),
      },
    },
    willRespondWith: {
      status: 201,
      headers: { 'Content-Type': 'application/json' },
      body: {
        id: like(123),
        name: like('Bob'),
        email: regex(/\S+@\S+\.\S+/, 'test@example.com'),
        createdAt: regex(/\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/, '2025-12-04T10:00:00Z'),
      },
    },
  });

  const client = new UserClient('http://localhost:1234');
  const user = await client.createUser({ name: 'Bob', email: 'test@example.com' });

  expect(user.id).toBeDefined();
  expect(user.createdAt).toMatch(/\d{4}-\d{2}-\d{2}/);
});
```

---

#### Error Responses

```javascript
it('returns 404 for non-existent user', async () => {
  await provider.addInteraction({
    state: 'user with ID 999 does not exist',
    uponReceiving: 'a request for non-existent user',
    withRequest: {
      method: 'GET',
      path: '/users/999',
    },
    willRespondWith: {
      status: 404,
      headers: { 'Content-Type': 'application/json' },
      body: {
        error: like('User not found'),
        code: like('NOT_FOUND'),
      },
    },
  });

  const client = new UserClient('http://localhost:1234');
  await expect(client.getUser(999)).rejects.toThrow('User not found');
});
```

---

### Provider Verification Patterns

#### State Handlers

**Purpose**: Set up provider state before each interaction is verified.

```javascript
const { Verifier } = require('@pact-foundation/pact');

describe('User API Pact Verification', () => {
  let server;

  beforeAll(async () => {
    server = await startServer(); // Start actual provider
  });

  afterAll(() => server.close());

  it('verifies consumer contracts', () => {
    return new Verifier({
      provider: 'UserAPI',
      providerBaseUrl: 'http://localhost:3000',
      pactBrokerUrl: 'https://pact-broker.example.com',
      publishVerificationResult: true,
      providerVersion: process.env.GIT_COMMIT,
      providerVersionTags: ['main', 'dev'],
      stateHandlers: {
        'user with ID 1 exists': async () => {
          await db.users.deleteAll();
          await db.users.insert({ id: 1, name: 'Alice', email: 'alice@example.com' });
        },
        'no user with email test@example.com exists': async () => {
          await db.users.deleteWhere({ email: 'test@example.com' });
        },
        'user with ID 999 does not exist': async () => {
          await db.users.deleteWhere({ id: 999 });
        },
      },
    }).verifyProvider();
  });
});
```

**State Handler Best Practices**:
- Use test database (never production)
- Clean state before each interaction
- Be idempotent (running twice should produce same result)
- Handle setup AND teardown if needed
- Keep states descriptive and specific

---

#### Request Filters (Authentication)

```javascript
new Verifier({
  provider: 'UserAPI',
  providerBaseUrl: 'http://localhost:3000',
  pactBrokerUrl: 'https://pact-broker.example.com',
  requestFilter: (req, res, next) => {
    // Add authentication header to all requests
    req.headers['Authorization'] = 'Bearer test-token-12345';
    next();
  },
  stateHandlers: { /* ... */ },
}).verifyProvider();
```

---

### Pact Broker Integration

**What is Pact Broker?**

Pact Broker is a repository for sharing Pact contracts and verification results. It enables:
- Centralized contract storage
- Version tracking and tagging
- Cross-team collaboration
- CI/CD integration with `can-i-deploy`
- Webhooks for triggering builds

**Self-Hosted Deployment**:
```yaml
# docker-compose.yml
version: '3'
services:
  pact-broker:
    image: pactfoundation/pact-broker:latest
    ports:
      - "9292:9292"
    environment:
      PACT_BROKER_DATABASE_URL: postgres://pactbroker:password@postgres/pactbroker
      PACT_BROKER_BASIC_AUTH_USERNAME: admin
      PACT_BROKER_BASIC_AUTH_PASSWORD: password
    depends_on:
      - postgres

  postgres:
    image: postgres:15
    environment:
      POSTGRES_USER: pactbroker
      POSTGRES_PASSWORD: password
      POSTGRES_DB: pactbroker
    volumes:
      - postgres-data:/var/lib/postgresql/data

volumes:
  postgres-data:
```

**Publishing Contracts**:
```bash
pact-broker publish ./pacts \
  --consumer-app-version=$GIT_COMMIT \
  --branch=$GIT_BRANCH \
  --tag=$GIT_BRANCH \
  --broker-base-url=https://pact-broker.example.com \
  --broker-username=admin \
  --broker-password=password
```

**Verifying Contracts (Provider)**:
```javascript
new Verifier({
  pactBrokerUrl: 'https://pact-broker.example.com',
  pactBrokerUsername: 'admin',
  pactBrokerPassword: 'password',
  consumerVersionSelectors: [
    { tag: 'main', latest: true },      // Latest from main branch
    { tag: 'production', latest: true }, // Currently in production
    { deployedOrReleased: true },        // All deployed versions
  ],
  publishVerificationResult: true,
  providerVersion: process.env.GIT_COMMIT,
  providerVersionBranch: process.env.GIT_BRANCH,
}).verifyProvider();
```

---

## Schema Validation (Alternative Approach)

### JSON Schema Validation

**When to Use JSON Schema Instead of Pact**:
- Provider-first API design (not consumer-driven)
- Need to validate against OpenAPI/Swagger specs
- Simpler setup for single provider, multiple consumers
- Less granular control needed

**Example (Using AJV)**:
```javascript
const Ajv = require('ajv');
const ajv = new Ajv();

const userSchema = {
  type: 'object',
  properties: {
    id: { type: 'integer' },
    name: { type: 'string', minLength: 1 },
    email: { type: 'string', format: 'email' },
    createdAt: { type: 'string', format: 'date-time' },
  },
  required: ['id', 'name', 'email'],
  additionalProperties: false,
};

describe('User API Schema Validation', () => {
  const validate = ajv.compile(userSchema);

  it('GET /users/:id returns valid user schema', async () => {
    const response = await request(app).get('/users/1');

    expect(response.status).toBe(200);
    expect(validate(response.body)).toBe(true);

    if (!validate(response.body)) {
      console.error(validate.errors);
      throw new Error('Schema validation failed');
    }
  });

  it('rejects invalid user data', async () => {
    const invalidUser = { id: 1, name: '' }; // Missing email, empty name

    expect(validate(invalidUser)).toBe(false);
    expect(validate.errors).toContainEqual(
      expect.objectContaining({
        keyword: 'minLength',
        dataPath: '/name',
      })
    );
  });
});
```

**JSON Schema Validation Best Practices**:
- Define schemas in separate files (reusable)
- Use `$ref` for nested schemas
- Enable `strict` mode to catch schema errors
- Generate schemas from TypeScript types (`typescript-json-schema`)
- Validate both request and response bodies

---

### OpenAPI Contract Testing

**OpenAPI Specification (OAS)** defines complete API contracts including:
- Endpoints and methods
- Request/response schemas
- Authentication requirements
- Example requests/responses

**Validating Against OpenAPI Spec**:
```javascript
const SwaggerParser = require('@apidevtools/swagger-parser');
const Ajv = require('ajv');
const addFormats = require('ajv-formats');

describe('OpenAPI Contract Tests', () => {
  let api, ajv;

  beforeAll(async () => {
    api = await SwaggerParser.validate('./openapi.yaml');
    ajv = new Ajv();
    addFormats(ajv);
  });

  it('GET /users/:id matches OpenAPI schema', async () => {
    const response = await request(app).get('/users/1');

    // Get schema from OpenAPI spec
    const schema = api.paths['/users/{id}'].get.responses['200'].content['application/json'].schema;
    const validate = ajv.compile(schema);

    expect(validate(response.body)).toBe(true);
  });

  it('POST /users validates request body', async () => {
    const requestSchema = api.paths['/users'].post.requestBody.content['application/json'].schema;
    const validate = ajv.compile(requestSchema);

    const validRequest = { name: 'Alice', email: 'alice@example.com' };
    expect(validate(validRequest)).toBe(true);

    const invalidRequest = { name: 'Alice' }; // Missing required email
    expect(validate(invalidRequest)).toBe(false);
  });
});
```

**Tools for OpenAPI Testing**:
- **Prism**: Mock server from OpenAPI spec, validates requests/responses
- **Dredd**: Automated API testing against OpenAPI/Swagger specs
- **Postman**: Import OpenAPI spec, auto-generate validation tests
- **openapi-validator**: Express middleware for runtime validation

---

## Contract Versioning and Evolution

### Semantic Versioning for APIs

**Version Format**: `MAJOR.MINOR.PATCH` (e.g., `2.3.1`)

- **MAJOR**: Breaking changes (remove endpoint, change required fields)
- **MINOR**: Backward-compatible additions (new endpoint, optional field)
- **PATCH**: Bug fixes, no API changes

**Example**:
- `1.0.0` → `1.1.0`: Added new `/users/:id/orders` endpoint (minor)
- `1.1.0` → `2.0.0`: Removed `/legacy-users` endpoint (major)
- `2.0.0` → `2.0.1`: Fixed bug in date formatting (patch)

---

### What Constitutes a Breaking Change?

**Breaking Changes** (require major version bump):
- Remove or rename an endpoint
- Remove a field from response
- Change field type (string → number)
- Make optional parameter required
- Change authentication mechanism
- Change error response format
- Rename request/response properties

**Non-Breaking Changes** (minor version bump):
- Add new endpoint
- Add optional field to request
- Add new field to response
- Make required parameter optional
- Add new optional header

**Example**:
```javascript
// Version 1.0.0
GET /users/1
Response: { id: 1, name: "Alice" }

// Version 1.1.0 (non-breaking: added field)
GET /users/1
Response: { id: 1, name: "Alice", email: "alice@example.com" }

// Version 2.0.0 (breaking: renamed field)
GET /users/1
Response: { id: 1, fullName: "Alice", email: "alice@example.com" }
```

---

### Versioning Strategies

#### URL Path Versioning (Recommended)

```
GET /v1/users/1
GET /v2/users/1
```

**Pros**:
- Explicit and visible in URLs
- Easy to route to different implementations
- Clear in logs and monitoring

**Cons**:
- Proliferation of URLs
- Must maintain multiple codebases

---

#### Header-Based Versioning

```
GET /users/1
Headers:
  Accept: application/vnd.myapi.v2+json
```

**Pros**:
- Clean URLs
- Fine-grained control

**Cons**:
- Less visible (hidden in headers)
- Harder to test manually (cURL, browser)

---

#### Query Parameter Versioning

```
GET /users/1?api-version=2
```

**Pros**:
- Simple implementation
- Easy to test

**Cons**:
- Not RESTful
- Mixes versioning with query params

---

### Backward Compatibility Strategies

**Strategy 1: Additive Changes Only**

```javascript
// Version 1.0.0
{
  "id": 1,
  "name": "Alice"
}

// Version 1.1.0 (backward compatible)
{
  "id": 1,
  "name": "Alice",
  "email": "alice@example.com"  // New field (optional for consumers)
}

// Consumer using v1.0.0 ignores new field
const { id, name } = response;
```

**Strategy 2: Default Values for New Fields**

```javascript
// Provider ensures new field has default if not provided
function createUser(data) {
  return {
    id: generateId(),
    name: data.name,
    email: data.email || 'noreply@example.com',  // Default for old consumers
    role: data.role || 'user',  // Default role
  };
}
```

**Strategy 3: Parallel Versions**

```javascript
// Support v1 and v2 simultaneously
app.get('/v1/users/:id', (req, res) => {
  const user = await db.users.findById(req.params.id);
  res.json({ id: user.id, name: user.name });  // v1 format
});

app.get('/v2/users/:id', (req, res) => {
  const user = await db.users.findById(req.params.id);
  res.json({ id: user.id, fullName: user.name, email: user.email });  // v2 format
});
```

---

### Deprecation and Sunset Policies

**Deprecation Workflow**:
1. **Announce**: Notify consumers 6+ months before removal
2. **Warn**: Add deprecation headers to responses
3. **Monitor**: Track usage of deprecated endpoints
4. **Sunset**: Set end-of-life date and communicate
5. **Remove**: Delete deprecated code after sunset date

**Example Deprecation Header**:
```
Deprecation: Sun, 11 Jun 2026 00:00:00 GMT
Sunset: Sun, 11 Dec 2026 00:00:00 GMT
Link: <https://api.example.com/docs/migration>; rel="alternate"
```

**Monitoring Deprecated Usage**:
```javascript
app.get('/v1/users/:id', (req, res) => {
  // Log usage of deprecated endpoint
  logger.warn('Deprecated endpoint accessed', {
    endpoint: '/v1/users/:id',
    consumer: req.headers['user-agent'],
  });

  res.set('Deprecation', 'Sun, 11 Jun 2026 00:00:00 GMT');
  res.set('Sunset', 'Sun, 11 Dec 2026 00:00:00 GMT');

  // Return response
  const user = await db.users.findById(req.params.id);
  res.json({ id: user.id, name: user.name });
});
```

---

## CI/CD Integration

### Consumer CI Pipeline

**Step 1: Run Consumer Tests**
```yaml
# .github/workflows/consumer-tests.yml
name: Consumer Contract Tests

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - run: npm ci
      - run: npm test  # Runs Pact consumer tests, generates pacts

      - name: Publish pacts to broker
        if: github.ref == 'refs/heads/main'
        run: |
          npx pact-broker publish ./pacts \
            --consumer-app-version=${{ github.sha }} \
            --branch=${{ github.ref_name }} \
            --broker-base-url=${{ secrets.PACT_BROKER_URL }} \
            --broker-token=${{ secrets.PACT_BROKER_TOKEN }}
```

---

### Provider CI Pipeline

**Step 2: Verify Provider Against Contracts**
```yaml
# .github/workflows/provider-verification.yml
name: Provider Verification

on:
  push:
    branches: [main]
  repository_dispatch:
    types: [pact_changed]  # Triggered by webhook from Pact Broker

jobs:
  verify:
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: test

    steps:
      - uses: actions/checkout@v3
      - run: npm ci
      - run: npm run test:pact:verify  # Verifies provider against pacts
        env:
          PACT_BROKER_URL: ${{ secrets.PACT_BROKER_URL }}
          PACT_BROKER_TOKEN: ${{ secrets.PACT_BROKER_TOKEN }}
          GIT_COMMIT: ${{ github.sha }}
          GIT_BRANCH: ${{ github.ref_name }}
```

---

### Can-I-Deploy in Deployment Pipeline

**Step 3: Check Deployment Safety**
```yaml
# .github/workflows/deploy.yml
name: Deploy to Production

on:
  push:
    branches: [main]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Can I deploy?
        run: |
          npx pact-broker can-i-deploy \
            --pacticipant UserAPI \
            --version=${{ github.sha }} \
            --to-environment production \
            --broker-base-url=${{ secrets.PACT_BROKER_URL }} \
            --broker-token=${{ secrets.PACT_BROKER_TOKEN }} \
            --retry-while-unknown=12 \
            --retry-interval=10

      - name: Deploy to production
        if: success()
        run: ./deploy.sh production

      - name: Record deployment
        if: success()
        run: |
          npx pact-broker record-deployment \
            --pacticipant UserAPI \
            --version=${{ github.sha }} \
            --environment production \
            --broker-base-url=${{ secrets.PACT_BROKER_URL }} \
            --broker-token=${{ secrets.PACT_BROKER_TOKEN }}
```

**What `can-i-deploy` Checks**:
- All consumer pacts verified by this provider version?
- Are contracts compatible with consumers already in target environment?
- Any pending verifications?

**Workflow**:
1. Consumer publishes pact → triggers provider verification (webhook)
2. Provider runs verification → publishes results to broker
3. Deployment checks `can-i-deploy` → blocks if verification failed
4. Safe deployment proceeds → records deployment in broker

---

### Pact Broker Webhooks

**Setup Webhook** (triggers provider build when consumer publishes pact):
```json
{
  "events": [
    { "name": "contract_content_changed" }
  ],
  "request": {
    "method": "POST",
    "url": "https://ci.example.com/api/builds",
    "headers": {
      "Content-Type": "application/json",
      "Authorization": "Bearer ${user.ci_token}"
    },
    "body": {
      "repository": "UserAPI",
      "branch": "main",
      "reason": "Pact changed for ${pactbroker.consumerName}"
    }
  }
}
```

---

## Microservices Testing Patterns

### Service Boundary Testing

**Test Only Direct Dependencies**:

```
┌─────────────┐
│   Frontend  │  ← Consumer (tests contract with API Gateway)
└─────────────┘
       ↓
┌─────────────┐
│ API Gateway │  ← Provider (verifies frontend contract)
└─────────────┘  ← Consumer (tests contract with User Service)
       ↓
┌─────────────┐
│UserService  │  ← Provider (verifies API Gateway contract)
└─────────────┘
```

**Anti-Pattern**: Frontend testing contract with User Service directly (skip API Gateway)
**Best Practice**: Each service only tests contracts with immediate neighbors

---

### Mock Services for Development

**Use Pact Mock Provider for Local Development**:
```javascript
const { Pact } = require('@pact-foundation/pact');

const mockProvider = new Pact({
  consumer: 'Frontend',
  provider: 'UserAPI',
  port: 8080,
  log: path.resolve(process.cwd(), 'logs', 'pact.log'),
  dir: path.resolve(process.cwd(), 'pacts'),
});

// Start mock provider for development
mockProvider.setup().then(() => {
  console.log('Mock UserAPI running on http://localhost:8080');
  console.log('Frontend can develop against mock without real backend');
});
```

**Benefits**:
- Frontend develops independently of backend availability
- No flaky tests due to backend issues
- Fast feedback loop

---

### Message Queue Contract Testing

**Async Messaging with Pact**:
```javascript
const { MessageConsumerPact } = require('@pact-foundation/pact');

describe('Order Created Event', () => {
  const messagePact = new MessageConsumerPact({
    consumer: 'NotificationService',
    provider: 'OrderService',
  });

  it('handles order created event', () => {
    return messagePact
      .expectsToReceive('an order created event')
      .withContent({
        eventType: 'ORDER_CREATED',
        orderId: like(123),
        customerId: like(456),
        total: like(99.99),
        createdAt: regex(/\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/, '2025-12-04T10:00:00Z'),
      })
      .withMetadata({
        contentType: 'application/json',
      })
      .verify((message) => {
        // Process message with actual consumer code
        const handler = new OrderEventHandler();
        return handler.handleOrderCreated(message);
      });
  });
});
```

**Provider Verification (Message Producer)**:
```javascript
const { MessageProviderPact } = require('@pact-foundation/pact');

describe('Order Service Message Provider', () => {
  it('verifies message contracts', () => {
    return new MessageProviderPact({
      messageProviders: {
        'an order created event': () => ({
          eventType: 'ORDER_CREATED',
          orderId: 123,
          customerId: 456,
          total: 99.99,
          createdAt: '2025-12-04T10:00:00Z',
        }),
      },
    }).verify();
  });
});
```

---

## Quick Reference

### Pact vs Schema Validation

| Aspect | Pact (CDC) | JSON Schema / OpenAPI |
|--------|------------|----------------------|
| **Approach** | Consumer-driven | Provider-driven |
| **Focus** | Actual usage patterns | Complete API specification |
| **Setup Complexity** | Higher (broker, webhooks) | Lower (just schema files) |
| **Flexibility** | Tests only what consumers use | Tests entire API surface |
| **Bidirectional** | Yes (consumer + provider tests) | No (provider tests only) |
| **Best For** | Microservices, cross-team APIs | Public APIs, documentation |

---

### Contract Testing Checklist

**Consumer Side**:
- [ ] Consumer tests define expected interactions
- [ ] Pact files generated and published to broker
- [ ] Tests use matchers (not exact values)
- [ ] Consumer version tagged (e.g., `main`, `production`)
- [ ] Tests run on every commit

**Provider Side**:
- [ ] Provider verification tests fetch pacts from broker
- [ ] State handlers set up required data
- [ ] Verification results published to broker
- [ ] Provider version tagged with environment
- [ ] Verification triggered by pact changes (webhook)

**CI/CD Integration**:
- [ ] Consumer publishes pacts after successful tests
- [ ] Provider verifies on every build
- [ ] `can-i-deploy` blocks unsafe deployments
- [ ] Deployment recorded in broker
- [ ] Webhooks trigger cross-team builds

**Versioning**:
- [ ] API versioned semantically (MAJOR.MINOR.PATCH)
- [ ] Breaking changes increment MAJOR version
- [ ] Deprecation policy documented and enforced
- [ ] Backward compatibility maintained for N-1 versions
- [ ] Sunset dates communicated 6+ months in advance

---

### Common Pitfalls

**Pitfall 1: Testing Implementation Details**
- **Bad**: Exact value matching (`name: 'Alice'`)
- **Good**: Type matching (`name: like('Alice')`)

**Pitfall 2: Flaky State Handlers**
- **Bad**: State handler doesn't clean up previous data
- **Good**: Truncate tables before inserting test data

**Pitfall 3: Ignoring `can-i-deploy`**
- **Bad**: Deploy without checking contract verification
- **Good**: Block deployment if `can-i-deploy` fails

**Pitfall 4: Provider-First Design**
- **Bad**: Provider builds API, consumers adapt
- **Good**: Consumers define needs, provider implements

**Pitfall 5: Over-Specifying Contracts**
- **Bad**: Test every possible response field
- **Good**: Test only fields consumer actually uses

---

### Tools and Resources

**Pact Implementations**:
- **JavaScript/TypeScript**: `@pact-foundation/pact`
- **Python**: `pact-python`
- **Java**: `au.com.dius.pact`
- **Ruby**: `pact` gem
- **Go**: `pact-go`
- **.NET**: `PactNet`

**Schema Validation**:
- **AJV**: Fast JSON Schema validator (JavaScript)
- **Prism**: Mock server from OpenAPI specs
- **Dredd**: API testing against OpenAPI/Swagger
- **json-schema** (Python), **jsonschema** (Ruby)

**Pact Broker**:
- Self-hosted: `pactfoundation/pact-broker` Docker image
- SaaS: Pactflow (commercial, hosted by Pact Foundation)

**CI/CD**:
- `pact-broker` CLI: Publish pacts, can-i-deploy, record deployments
- GitHub Actions: `pactfoundation/setup-pact`
- GitLab CI, Jenkins, CircleCI integrations available

---

**Reference Version**: 1.0.0
**Last Updated**: 2025-12-04

---

## Sources

- [Introduction | Pact Docs](https://docs.pact.io/)
- [Consumer Driven Contracts with Pact | Baeldung](https://www.baeldung.com/pact-junit-consumer-driven-contracts)
- [What is Consumer-Driven Contract Testing (CDC)? | Pactflow](https://pactflow.io/what-is-consumer-driven-contract-testing/)
- [Schema-based contract testing with JSON Schema and OpenAPI](https://pactflow.io/blog/contract-testing-using-json-schemas-and-open-api-part-2/)
- [Contract testing with OpenAPI | Speakeasy](https://www.speakeasy.com/blog/contract-testing-with-openapi)
- [How API Schema Validation Boosts Effective Contract Testing | Zuplo](https://zuplo.com/blog/2025/04/15/how-api-schema-validation-boosts-effective-contract-testing)
- [Creating, evolving, and versioning microservice APIs and contracts | Microsoft Learn](https://learn.microsoft.com/en-us/dotnet/architecture/microservices/architect-microservice-container-applications/maintain-microservice-apis)
- [Best practices for versioning API contracts | Medium](https://proteinshaikh.medium.com/best-practices-for-versioning-api-contracts-to-avoid-breaking-changes-a54fbc6d469d)
- [Can I Deploy | Pact Docs](https://docs.pact.io/pact_broker/can_i_deploy)
- [CI/CD Setup Guide | Pact Docs](https://docs.pact.io/pact_nirvana)
