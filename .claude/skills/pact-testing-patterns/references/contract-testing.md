# Contract Testing Reference

**Location**: `skills/pact-testing-patterns/references/contract-testing.md`

**Purpose**: Comprehensive guide to contract testing, consumer-driven contracts, schema validation, and microservices integration testing.

**Used by**: pact-test-engineer agent when designing contract tests for distributed systems and microservices

**Related files**:
- `../SKILL.md` - Quick reference and decision tree
- `test-strategies.md` - Overall testing approaches
- `test-coverage.md` - Coverage metrics and analysis

---

## What is Contract Testing?

### Definition

**Contract Testing** is a testing methodology that verifies interactions between service boundaries in distributed systems. It validates that a provider (server/API) meets the expectations of its consumers (clients), ensuring that communication contracts are honored without requiring end-to-end integration tests.

**Key Concepts**:
- **Consumer**: The application that initiates a request (client, frontend, service A)
- **Provider**: The application that responds to a request (API, backend, service B)
- **Contract**: A formal agreement defining expected request/response interactions
- **Pact**: A specific contract file (JSON) generated by consumer tests

**Note**: This section refers to the Pact **testing framework**, which is distinct from the PACT **methodology** (Prepare, Architect, Code, Test) used in this skill library.

---

### Why Contract Testing?

**Problems with Traditional Integration Testing**:
- **Slow**: Requires spinning up multiple services, databases, message queues
- **Brittle**: Fails due to infrastructure issues unrelated to contract violations
- **Expensive**: Needs complex test environments, orchestration, and maintenance
- **Delayed Feedback**: Often only run in staging/pre-production environments

**Contract Testing Benefits**:
- **Fast**: Tests run in milliseconds (no real service dependencies)
- **Isolated**: Each service tested independently with mocked interactions
- **Early Detection**: Catch integration issues before deployment
- **API Evolution**: Safely evolve APIs with confidence in compatibility
- **Cross-Team Collaboration**: Contracts serve as living documentation

**When to Use Contract Testing**:
- Microservices architecture with multiple service dependencies
- Frontend applications consuming backend APIs
- Third-party API integrations
- Messaging systems (event-driven architectures)
- Mobile apps communicating with backend services

---

## Consumer-Driven Contracts (CDC)

### Philosophy

**Consumer-Driven Contract Testing (CDC)** is an approach where consumers define the contract by specifying their expectations of the provider. This inverts traditional provider-first API design.

**Traditional Approach**:
```
Provider defines API → Consumers adapt to API → Breaking changes affect all consumers
```

**Consumer-Driven Approach**:
```
Consumers define expectations → Provider implements to meet expectations → Changes driven by real needs
```

**Benefits**:
- **Focus on Usage**: Provider only implements what consumers actually need
- **Prevents Over-Engineering**: No unused API endpoints or fields
- **Safe Refactoring**: Provider can refactor as long as consumer expectations are met
- **Bilateral Testing**: Both consumer and provider have test suites

---

### CDC Workflow

**Step 1: Consumer Writes Tests**
```javascript
// Consumer test (frontend testing API expectations)
const { Pact } = require('@pact-foundation/pact');

describe('User API', () => {
  const provider = new Pact({
    consumer: 'UserUI',
    provider: 'UserAPI',
  });

  beforeAll(() => provider.setup());
  afterEach(() => provider.verify());  // Verify interaction occurred
  afterAll(() => provider.finalize()); // Write pact file

  it('retrieves user by ID', async () => {
    // Define expected interaction
    await provider.addInteraction({
      state: 'user with ID 1 exists',
      uponReceiving: 'a request for user 1',
      withRequest: {
        method: 'GET',
        path: '/users/1',
        headers: { Accept: 'application/json' },
      },
      willRespondWith: {
        status: 200,
        headers: { 'Content-Type': 'application/json' },
        body: {
          id: 1,
          name: 'Alice',
          email: 'alice@example.com',
        },
      },
    });

    // Run consumer code against mock provider
    const response = await apiClient.getUser(1);

    expect(response.id).toBe(1);
    expect(response.name).toBe('Alice');
  });
});
```

**Test Isolation Best Practices**:
- Each test should define its own interactions (`addInteraction`)
- Use `afterEach(() => provider.verify())` to ensure expected calls were made
- Create a new Pact instance per test suite (not per test)
- Avoid shared state between tests—interactions are test-specific
- If tests share the same mock provider, ensure `verify()` clears interactions between tests

**What Happens**:
1. Consumer test defines expected request/response
2. Pact creates mock provider that responds as expected
3. Consumer code runs against mock provider
4. `provider.finalize()` writes the contract file (`UserUI-UserAPI.json`)

**Important**: The consumer test lifecycle must include:
- `provider.setup()` - Starts mock server before tests
- `provider.verify()` - Validates interaction occurred as expected (after each test)
- `provider.finalize()` - Writes pact file and shuts down server (after all tests)

**Step 2: Publish Contract to Pact Broker**
```bash
# Consumer publishes contract after tests pass
pact-broker publish pacts/UserUI-UserAPI.json \
  --consumer-app-version=1.2.3 \
  --tag=main \
  --broker-base-url=https://pact-broker.example.com
```

**Step 3: Provider Verifies Contract**
```javascript
// Provider verification test (backend verifying it meets consumer expectations)
const { Verifier } = require('@pact-foundation/pact');

describe('Pact Verification', () => {
  it('validates the expectations of UserUI', async () => {
    const opts = {
      provider: 'UserAPI',
      providerBaseUrl: 'http://localhost:3000',
      pactBrokerUrl: 'https://pact-broker.example.com',
      publishVerificationResult: true,
      providerVersion: '2.0.1',
      stateHandlers: {
        'user with ID 1 exists': async () => {
          // Setup: Insert test user into database
          await db.users.insert({ id: 1, name: 'Alice', email: 'alice@example.com' });
        },
      },
    };

    try {
      await new Verifier(opts).verifyProvider();
    } catch (error) {
      // Log detailed verification failures for debugging
      console.error('Contract verification failed:', error.message);
      throw error; // Re-throw to fail the test
    }
  });
});
```

**Handling Verification Failures**:
- Verification errors indicate the provider doesn't meet consumer expectations
- Check error output for: missing endpoints, wrong response structure, status code mismatches
- State handler failures can cause false negatives—ensure data setup succeeds
- Use `enablePending: true` during development to continue despite failures

**What Happens**:
1. Provider fetches contract from Pact Broker
2. For each interaction, provider sets up required state
3. Pact sends real HTTP request to provider
4. Provider response is validated against contract expectations
5. Verification result published to Pact Broker

**Step 4: Can-I-Deploy Check**
```bash
# Before deploying, check if all contracts are verified
pact-broker can-i-deploy \
  --pacticipant UserAPI \
  --version 2.0.1 \
  --to-environment production \
  --broker-base-url=https://pact-broker.example.com
```

**Output**:
```
Computer says yes \o/

CONSUMER       | C.VERSION | PROVIDER  | P.VERSION | SUCCESS? | RESULT
---------------|-----------|-----------|-----------|----------|--------
UserUI         | 1.2.3     | UserAPI   | 2.0.1     | true     | ✓ Verified
```

If verification fails, deployment is blocked until contracts are satisfied.

---

## Pact Framework Deep Dive

### Installation

**JavaScript/TypeScript**:
```bash
npm install --save-dev @pact-foundation/pact
```

**Python**:
```bash
pip install pact-python
```

**Java**:
```xml
<dependency>
  <groupId>au.com.dius.pact.consumer</groupId>
  <artifactId>junit5</artifactId>
  <version>4.6.13</version>
  <scope>test</scope>
</dependency>
```

---

### Consumer Test Patterns

#### Basic GET Request

```javascript
const { Pact } = require('@pact-foundation/pact');
const { like, eachLike } = require('@pact-foundation/pact').MatchersV3;

describe('Products API', () => {
  const provider = new Pact({
    consumer: 'ProductUI',
    provider: 'ProductAPI',
    port: 1234,
  });

  beforeAll(() => provider.setup());
  afterEach(() => provider.verify());
  afterAll(() => provider.finalize());

  it('retrieves all products', async () => {
    await provider.addInteraction({
      state: 'products exist',
      uponReceiving: 'a request for all products',
      withRequest: {
        method: 'GET',
        path: '/products',
      },
      willRespondWith: {
        status: 200,
        headers: { 'Content-Type': 'application/json' },
        body: eachLike({
          id: like(1),
          name: like('Product A'),
          price: like(29.99),
        }),
      },
    });

    const client = new ProductClient('http://localhost:1234');
    const products = await client.getProducts();

    expect(products.length).toBeGreaterThan(0);
    expect(products[0]).toHaveProperty('id');
    expect(products[0]).toHaveProperty('name');
  });
});
```

**Matchers**:
- `like(value)`: Matches type, not exact value (flexible)
- `eachLike(value)`: Matches array where each item matches pattern
- `regex(pattern, example)`: Matches regex pattern
- `term(pattern, example)`: Alias for regex

---

#### POST Request with Body

```javascript
it('creates a new user', async () => {
  await provider.addInteraction({
    state: 'no user with email test@example.com exists',
    uponReceiving: 'a request to create a user',
    withRequest: {
      method: 'POST',
      path: '/users',
      headers: { 'Content-Type': 'application/json' },
      body: {
        name: like('Bob'),
        email: regex(/\S+@\S+\.\S+/, 'test@example.com'),
      },
    },
    willRespondWith: {
      status: 201,
      headers: { 'Content-Type': 'application/json' },
      body: {
        id: like(123),
        name: like('Bob'),
        email: regex(/\S+@\S+\.\S+/, 'test@example.com'),
        createdAt: regex(/\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/, '2025-12-04T10:00:00Z'),
      },
    },
  });

  const client = new UserClient('http://localhost:1234');
  const user = await client.createUser({ name: 'Bob', email: 'test@example.com' });

  expect(user.id).toBeDefined();
  expect(user.createdAt).toMatch(/\d{4}-\d{2}-\d{2}/);
});
```

---

#### Error Responses

```javascript
it('returns 404 for non-existent user', async () => {
  await provider.addInteraction({
    state: 'user with ID 999 does not exist',
    uponReceiving: 'a request for non-existent user',
    withRequest: {
      method: 'GET',
      path: '/users/999',
    },
    willRespondWith: {
      status: 404,
      headers: { 'Content-Type': 'application/json' },
      body: {
        error: like('User not found'),
        code: like('NOT_FOUND'),
      },
    },
  });

  const client = new UserClient('http://localhost:1234');
  await expect(client.getUser(999)).rejects.toThrow('User not found');
});
```

---

### Provider Verification Patterns

#### State Handlers

**Purpose**: Set up provider state before each interaction is verified.

```javascript
const { Verifier } = require('@pact-foundation/pact');

describe('User API Pact Verification', () => {
  let server;

  beforeAll(async () => {
    server = await startServer(); // Start actual provider
  });

  afterAll(() => server.close());

  it('verifies consumer contracts', () => {
    return new Verifier({
      provider: 'UserAPI',
      providerBaseUrl: 'http://localhost:3000',
      pactBrokerUrl: 'https://pact-broker.example.com',
      publishVerificationResult: true,
      providerVersion: process.env.GIT_COMMIT,
      providerVersionTags: ['main', 'dev'],
      stateHandlers: {
        'user with ID 1 exists': async () => {
          await db.users.deleteAll();
          await db.users.insert({ id: 1, name: 'Alice', email: 'alice@example.com' });
        },
        'no user with email test@example.com exists': async () => {
          await db.users.deleteWhere({ email: 'test@example.com' });
        },
        'user with ID 999 does not exist': async () => {
          await db.users.deleteWhere({ id: 999 });
        },
      },
    }).verifyProvider();
  });
});
```

**State Handler Best Practices**:
- Use test database (never production)
- Clean state before each interaction
- Be idempotent (running twice should produce same result)
- Handle setup AND teardown if needed
- Keep states descriptive and specific

**Handling Conflicting States**:
When multiple consumers require conflicting states (e.g., "user 1 exists" vs "user 1 does not exist"):
- State handlers run per-interaction, so conflicts are resolved automatically
- Ensure each handler fully resets state—don't assume previous state
- Use `deleteAll()` before `insert()` to guarantee clean slate
- For complex scenarios, use database transactions with rollback after each interaction
- Consider using unique identifiers per consumer test to avoid collisions

---

#### Request Filters (Authentication)

```javascript
new Verifier({
  provider: 'UserAPI',
  providerBaseUrl: 'http://localhost:3000',
  pactBrokerUrl: 'https://pact-broker.example.com',
  requestFilter: (req, res, next) => {
    // Add authentication header to all requests
    req.headers['Authorization'] = 'Bearer test-token-12345';
    next();
  },
  stateHandlers: { /* ... */ },
}).verifyProvider();
```

---

### Pact Broker Integration

**What is Pact Broker?**

Pact Broker is a repository for sharing Pact contracts and verification results. It enables:
- Centralized contract storage
- Version tracking and tagging
- Cross-team collaboration
- CI/CD integration with `can-i-deploy`
- Webhooks for triggering builds

**Self-Hosted Deployment**:
```yaml
# docker-compose.yml
version: '3'
services:
  pact-broker:
    image: pactfoundation/pact-broker:latest
    ports:
      - "9292:9292"
    environment:
      PACT_BROKER_DATABASE_URL: postgres://pactbroker:password@postgres/pactbroker
      PACT_BROKER_BASIC_AUTH_USERNAME: admin
      PACT_BROKER_BASIC_AUTH_PASSWORD: password
    depends_on:
      - postgres

  postgres:
    image: postgres:15
    environment:
      POSTGRES_USER: pactbroker
      POSTGRES_PASSWORD: password
      POSTGRES_DB: pactbroker
    volumes:
      - postgres-data:/var/lib/postgresql/data

volumes:
  postgres-data:
```

**Publishing Contracts**:
```bash
pact-broker publish ./pacts \
  --consumer-app-version=$GIT_COMMIT \
  --branch=$GIT_BRANCH \
  --tag=$GIT_BRANCH \
  --broker-base-url=https://pact-broker.example.com \
  --broker-username=admin \
  --broker-password=password
```

**Verifying Contracts (Provider)**:
```javascript
new Verifier({
  pactBrokerUrl: 'https://pact-broker.example.com',
  pactBrokerUsername: 'admin',
  pactBrokerPassword: 'password',
  consumerVersionSelectors: [
    { tag: 'main', latest: true },      // Latest from main branch
    { tag: 'production', latest: true }, // Currently in production
    { deployedOrReleased: true },        // All deployed versions
  ],
  publishVerificationResult: true,
  providerVersion: process.env.GIT_COMMIT,
  providerVersionBranch: process.env.GIT_BRANCH,
}).verifyProvider();
```

---

## Schema Validation (Alternative Approach)

### JSON Schema Validation

**When to Use JSON Schema Instead of Pact**:
- Provider-first API design (not consumer-driven)
- Need to validate against OpenAPI/Swagger specs
- Simpler setup for single provider, multiple consumers
- Less granular control needed

**Example (Using AJV)**:
```javascript
const Ajv = require('ajv');
const ajv = new Ajv();

const userSchema = {
  type: 'object',
  properties: {
    id: { type: 'integer' },
    name: { type: 'string', minLength: 1 },
    email: { type: 'string', format: 'email' },
    createdAt: { type: 'string', format: 'date-time' },
  },
  required: ['id', 'name', 'email'],
  additionalProperties: false,
};

describe('User API Schema Validation', () => {
  const validate = ajv.compile(userSchema);

  it('GET /users/:id returns valid user schema', async () => {
    const response = await request(app).get('/users/1');

    expect(response.status).toBe(200);
    expect(validate(response.body)).toBe(true);

    if (!validate(response.body)) {
      console.error(validate.errors);
      throw new Error('Schema validation failed');
    }
  });

  it('rejects invalid user data', async () => {
    const invalidUser = { id: 1, name: '' }; // Missing email, empty name

    expect(validate(invalidUser)).toBe(false);
    expect(validate.errors).toContainEqual(
      expect.objectContaining({
        keyword: 'minLength',
        dataPath: '/name',
      })
    );
  });
});
```

**JSON Schema Validation Best Practices**:
- Define schemas in separate files (reusable)
- Use `$ref` for nested schemas
- Enable `strict` mode to catch schema errors
- Generate schemas from TypeScript types (`typescript-json-schema`)
- Validate both request and response bodies

---

### OpenAPI Contract Testing

**OpenAPI Specification (OAS)** defines complete API contracts including:
- Endpoints and methods
- Request/response schemas
- Authentication requirements
- Example requests/responses

**Validating Against OpenAPI Spec**:
```javascript
const SwaggerParser = require('@apidevtools/swagger-parser');
const Ajv = require('ajv');
const addFormats = require('ajv-formats');

describe('OpenAPI Contract Tests', () => {
  let api, ajv;

  beforeAll(async () => {
    api = await SwaggerParser.validate('./openapi.yaml');
    ajv = new Ajv();
    addFormats(ajv);
  });

  it('GET /users/:id matches OpenAPI schema', async () => {
    const response = await request(app).get('/users/1');

    // Get schema from OpenAPI spec
    const schema = api.paths['/users/{id}'].get.responses['200'].content['application/json'].schema;
    const validate = ajv.compile(schema);

    expect(validate(response.body)).toBe(true);
  });

  it('POST /users validates request body', async () => {
    const requestSchema = api.paths['/users'].post.requestBody.content['application/json'].schema;
    const validate = ajv.compile(requestSchema);

    const validRequest = { name: 'Alice', email: 'alice@example.com' };
    expect(validate(validRequest)).toBe(true);

    const invalidRequest = { name: 'Alice' }; // Missing required email
    expect(validate(invalidRequest)).toBe(false);
  });
});
```

**Tools for OpenAPI Testing**:
- **Prism**: Mock server from OpenAPI spec, validates requests/responses
- **Dredd**: Automated API testing against OpenAPI/Swagger specs
- **Postman**: Import OpenAPI spec, auto-generate validation tests
- **openapi-validator**: Express middleware for runtime validation

---

## Contract Versioning and Evolution

### Semantic Versioning for APIs

**Version Format**: `MAJOR.MINOR.PATCH` (e.g., `2.3.1`)

- **MAJOR**: Breaking changes (remove endpoint, change required fields)
- **MINOR**: Backward-compatible additions (new endpoint, optional field)
- **PATCH**: Bug fixes, no API changes

**Example**:
- `1.0.0` → `1.1.0`: Added new `/users/:id/orders` endpoint (minor)
- `1.1.0` → `2.0.0`: Removed `/legacy-users` endpoint (major)
- `2.0.0` → `2.0.1`: Fixed bug in date formatting (patch)

---

### What Constitutes a Breaking Change?

**Breaking Changes** (require major version bump):
- Remove or rename an endpoint
- Remove a field from response
- Change field type (string → number)
- Make optional parameter required
- Change authentication mechanism
- Change error response format
- Rename request/response properties

**Non-Breaking Changes** (minor version bump):
- Add new endpoint
- Add optional field to request
- Add new field to response
- Make required parameter optional
- Add new optional header

**Example**:
```javascript
// Version 1.0.0
GET /users/1
Response: { id: 1, name: "Alice" }

// Version 1.1.0 (non-breaking: added field)
GET /users/1
Response: { id: 1, name: "Alice", email: "alice@example.com" }

// Version 2.0.0 (breaking: renamed field)
GET /users/1
Response: { id: 1, fullName: "Alice", email: "alice@example.com" }
```

---

### Versioning Strategies

#### URL Path Versioning (Recommended)

```
GET /v1/users/1
GET /v2/users/1
```

**Pros**:
- Explicit and visible in URLs
- Easy to route to different implementations
- Clear in logs and monitoring

**Cons**:
- Proliferation of URLs
- Must maintain multiple codebases

---

#### Header-Based Versioning

```
GET /users/1
Headers:
  Accept: application/vnd.myapi.v2+json
```

**Pros**:
- Clean URLs
- Fine-grained control

**Cons**:
- Less visible (hidden in headers)
- Harder to test manually (cURL, browser)

---

#### Query Parameter Versioning

```
GET /users/1?api-version=2
```

**Pros**:
- Simple implementation
- Easy to test

**Cons**:
- Not RESTful
- Mixes versioning with query params

---

### Backward Compatibility Strategies

**Strategy 1: Additive Changes Only**

```javascript
// Version 1.0.0
{
  "id": 1,
  "name": "Alice"
}

// Version 1.1.0 (backward compatible)
{
  "id": 1,
  "name": "Alice",
  "email": "alice@example.com"  // New field (optional for consumers)
}

// Consumer using v1.0.0 ignores new field
const { id, name } = response;
```

**Strategy 2: Default Values for New Fields**

```javascript
// Provider ensures new field has default if not provided
function createUser(data) {
  return {
    id: generateId(),
    name: data.name,
    email: data.email || 'noreply@example.com',  // Default for old consumers
    role: data.role || 'user',  // Default role
  };
}
```

**Strategy 3: Parallel Versions**

```javascript
// Support v1 and v2 simultaneously
app.get('/v1/users/:id', (req, res) => {
  const user = await db.users.findById(req.params.id);
  res.json({ id: user.id, name: user.name });  // v1 format
});

app.get('/v2/users/:id', (req, res) => {
  const user = await db.users.findById(req.params.id);
  res.json({ id: user.id, fullName: user.name, email: user.email });  // v2 format
});
```

---

### Deprecation and Sunset Policies

**Deprecation Workflow**:
1. **Announce**: Notify consumers 6+ months before removal
2. **Warn**: Add deprecation headers to responses
3. **Monitor**: Track usage of deprecated endpoints
4. **Sunset**: Set end-of-life date and communicate
5. **Remove**: Delete deprecated code after sunset date

**Example Deprecation Header**:
```
Deprecation: Sun, 11 Jun 2026 00:00:00 GMT
Sunset: Sun, 11 Dec 2026 00:00:00 GMT
Link: <https://api.example.com/docs/migration>; rel="alternate"
```

**Monitoring Deprecated Usage**:
```javascript
app.get('/v1/users/:id', (req, res) => {
  // Log usage of deprecated endpoint
  logger.warn('Deprecated endpoint accessed', {
    endpoint: '/v1/users/:id',
    consumer: req.headers['user-agent'],
  });

  res.set('Deprecation', 'Sun, 11 Jun 2026 00:00:00 GMT');
  res.set('Sunset', 'Sun, 11 Dec 2026 00:00:00 GMT');

  // Return response
  const user = await db.users.findById(req.params.id);
  res.json({ id: user.id, name: user.name });
});
```

---

## CI/CD Integration

### Consumer CI Pipeline

**Step 1: Run Consumer Tests**
```yaml
# .github/workflows/consumer-tests.yml
name: Consumer Contract Tests

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - run: npm ci
      - run: npm test  # Runs Pact consumer tests, generates pacts

      - name: Publish pacts to broker
        if: github.ref == 'refs/heads/main'
        run: |
          npx pact-broker publish ./pacts \
            --consumer-app-version=${{ github.sha }} \
            --branch=${{ github.ref_name }} \
            --broker-base-url=${{ secrets.PACT_BROKER_URL }} \
            --broker-token=${{ secrets.PACT_BROKER_TOKEN }}
```

---

### Provider CI Pipeline

**Step 2: Verify Provider Against Contracts**
```yaml
# .github/workflows/provider-verification.yml
name: Provider Verification

on:
  push:
    branches: [main]
  repository_dispatch:
    types: [pact_changed]  # Triggered by webhook from Pact Broker

jobs:
  verify:
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: test

    steps:
      - uses: actions/checkout@v3
      - run: npm ci
      - run: npm run test:pact:verify  # Verifies provider against pacts
        env:
          PACT_BROKER_URL: ${{ secrets.PACT_BROKER_URL }}
          PACT_BROKER_TOKEN: ${{ secrets.PACT_BROKER_TOKEN }}
          GIT_COMMIT: ${{ github.sha }}
          GIT_BRANCH: ${{ github.ref_name }}
```

---

### Can-I-Deploy in Deployment Pipeline

**Step 3: Check Deployment Safety**
```yaml
# .github/workflows/deploy.yml
name: Deploy to Production

on:
  push:
    branches: [main]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Can I deploy?
        run: |
          npx pact-broker can-i-deploy \
            --pacticipant UserAPI \
            --version=${{ github.sha }} \
            --to-environment production \
            --broker-base-url=${{ secrets.PACT_BROKER_URL }} \
            --broker-token=${{ secrets.PACT_BROKER_TOKEN }} \
            --retry-while-unknown=12 \
            --retry-interval=10

      - name: Deploy to production
        if: success()
        run: ./deploy.sh production

      - name: Record deployment
        if: success()
        run: |
          npx pact-broker record-deployment \
            --pacticipant UserAPI \
            --version=${{ github.sha }} \
            --environment production \
            --broker-base-url=${{ secrets.PACT_BROKER_URL }} \
            --broker-token=${{ secrets.PACT_BROKER_TOKEN }}
```

**What `can-i-deploy` Checks**:
- All consumer pacts verified by this provider version?
- Are contracts compatible with consumers already in target environment?
- Any pending verifications?

**Workflow**:
1. Consumer publishes pact → triggers provider verification (webhook)
2. Provider runs verification → publishes results to broker
3. Deployment checks `can-i-deploy` → blocks if verification failed
4. Safe deployment proceeds → records deployment in broker

---

### Pact Broker Webhooks

**Setup Webhook** (triggers provider build when consumer publishes pact):
```json
{
  "events": [
    { "name": "contract_content_changed" }
  ],
  "request": {
    "method": "POST",
    "url": "https://ci.example.com/api/builds",
    "headers": {
      "Content-Type": "application/json",
      "Authorization": "Bearer ${user.ci_token}"
    },
    "body": {
      "repository": "UserAPI",
      "branch": "main",
      "reason": "Pact changed for ${pactbroker.consumerName}"
    }
  }
}
```

---

## Microservices Testing Patterns

### Service Boundary Testing

**Test Only Direct Dependencies**:

```
┌─────────────┐
│   Frontend  │  ← Consumer (tests contract with API Gateway)
└─────────────┘
       ↓
┌─────────────┐
│ API Gateway │  ← Provider (verifies frontend contract)
└─────────────┘  ← Consumer (tests contract with User Service)
       ↓
┌─────────────┐
│UserService  │  ← Provider (verifies API Gateway contract)
└─────────────┘
```

**Anti-Pattern**: Frontend testing contract with User Service directly (skip API Gateway)
**Best Practice**: Each service only tests contracts with immediate neighbors

---

### Mock Services for Development

**Use Pact Mock Provider for Local Development**:
```javascript
const { Pact } = require('@pact-foundation/pact');

const mockProvider = new Pact({
  consumer: 'Frontend',
  provider: 'UserAPI',
  port: 8080,
  log: path.resolve(process.cwd(), 'logs', 'pact.log'),
  dir: path.resolve(process.cwd(), 'pacts'),
});

// Start mock provider for development
mockProvider.setup().then(() => {
  console.log('Mock UserAPI running on http://localhost:8080');
  console.log('Frontend can develop against mock without real backend');
});
```

**Benefits**:
- Frontend develops independently of backend availability
- No flaky tests due to backend issues
- Fast feedback loop

---

### Message Queue Contract Testing

**Async Messaging with Pact**:
```javascript
const { MessageConsumerPact } = require('@pact-foundation/pact');

describe('Order Created Event', () => {
  const messagePact = new MessageConsumerPact({
    consumer: 'NotificationService',
    provider: 'OrderService',
  });

  it('handles order created event', () => {
    return messagePact
      .expectsToReceive('an order created event')
      .withContent({
        eventType: 'ORDER_CREATED',
        orderId: like(123),
        customerId: like(456),
        total: like(99.99),
        createdAt: regex(/\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/, '2025-12-04T10:00:00Z'),
      })
      .withMetadata({
        contentType: 'application/json',
      })
      .verify((message) => {
        // Process message with actual consumer code
        const handler = new OrderEventHandler();
        return handler.handleOrderCreated(message);
      });
  });
});
```

**Provider Verification (Message Producer)**:
```javascript
const { MessageProviderPact } = require('@pact-foundation/pact');

describe('Order Service Message Provider', () => {
  it('verifies message contracts', () => {
    return new MessageProviderPact({
      messageProviders: {
        'an order created event': () => ({
          eventType: 'ORDER_CREATED',
          orderId: 123,
          customerId: 456,
          total: 99.99,
          createdAt: '2025-12-04T10:00:00Z',
        }),
      },
    }).verify();
  });
});
```

**Message Queue Testing Best Practices**:
- Test idempotency: Verify handler produces same result when processing duplicate messages
- Test ordering: If message order matters, test out-of-order scenarios
- Test malformed messages: Verify graceful handling of schema violations
- Include message ID in tests for traceability and deduplication verification
- Mock external dependencies called by message handlers

---

## Troubleshooting

### Pact Verification Failing with "No pacts found"

**Symptoms**: Provider verification can't find consumer pacts to verify

**Root Causes**:
- Pact Broker URL incorrect or inaccessible
- Consumer hasn't published pacts yet
- Authentication credentials missing/invalid
- Network firewall blocking Pact Broker access
- Consumer version selector misconfigured

**Solutions**:
```javascript
// Debug pact retrieval
const { Verifier } = require('@pact-foundation/pact');

const opts = {
  provider: 'UserAPI',
  providerBaseUrl: 'http://localhost:3000',
  pactBrokerUrl: process.env.PACT_BROKER_URL,
  pactBrokerToken: process.env.PACT_BROKER_TOKEN,
  // Enable verbose logging
  logLevel: 'DEBUG',
  consumerVersionSelectors: [
    { tag: 'main', latest: true },
    { deployedOrReleased: true },
  ],
};

try {
  await new Verifier(opts).verifyProvider();
} catch (error) {
  console.error('Verification failed:', error.message);
  // Check if Pact Broker is reachable
  const response = await fetch(process.env.PACT_BROKER_URL);
  console.log('Pact Broker status:', response.status);
}

// Manually query Pact Broker to verify pacts exist
const pactUrl = `${process.env.PACT_BROKER_URL}/pacts/provider/UserAPI/latest`;
const pacts = await fetch(pactUrl, {
  headers: { 'Authorization': `Bearer ${process.env.PACT_BROKER_TOKEN}` }
});
console.log('Available pacts:', await pacts.json());
```

**Debugging Tips**:
- Verify Pact Broker URL is correct: `curl https://pact-broker.example.com`
- Check consumer pacts exist: `pact-broker list-latest-pact-versions --broker-base-url=...`
- Test authentication: `curl -H "Authorization: Bearer TOKEN" https://pact-broker.example.com/pacts`
- Review consumer version selectors (ensure tags match published pacts)

---

### State Handler Failures Causing False Negatives

**Symptoms**: Verification fails but provider implementation is correct

**Root Causes**:
- State handler doesn't set up required data
- Database not cleaned between state handlers
- Async state handler not awaited properly
- State handler throws error before data setup completes
- Test database connection issues

**Solutions**:
```javascript
// Robust state handlers with error handling
const stateHandlers = {
  'user with ID 1 exists': async () => {
    try {
      // Clean slate: delete all users first
      await db.users.deleteAll();

      // Insert required user
      const user = await db.users.insert({
        id: 1,
        name: 'Alice',
        email: 'alice@example.com'
      });

      console.log('State setup complete:', user);
      return user;
    } catch (error) {
      console.error('State handler failed:', error);
      throw new Error(`Failed to set up state "user with ID 1 exists": ${error.message}`);
    }
  },

  'no user with email test@example.com exists': async () => {
    try {
      await db.users.deleteWhere({ email: 'test@example.com' });
      console.log('State setup complete: user removed');
    } catch (error) {
      console.error('State cleanup failed:', error);
      throw error;
    }
  },
};

// Verify state handlers work independently
beforeAll(async () => {
  // Test database connection
  await db.ping();

  // Test each state handler
  for (const [state, handler] of Object.entries(stateHandlers)) {
    try {
      await handler();
      console.log(`✓ State handler "${state}" works`);
    } catch (error) {
      console.error(`✗ State handler "${state}" failed:`, error);
      throw error;
    }
  }
});
```

**Debugging Tips**:
- Test state handlers in isolation before running verification
- Check database state after handler runs: `await db.users.findAll()`
- Verify handler is async and returns promise
- Look for race conditions (multiple handlers modifying same data)
- Check database transaction rollback/commit behavior

---

### Consumer Tests Passing but Provider Verification Failing

**Symptoms**: Consumer tests generate pacts successfully, but provider can't verify them

**Root Causes**:
- Consumer mock provider differs from actual provider behavior
- Provider changed response format without updating consumer
- State names mismatch (consumer uses "user exists", provider expects "user with ID 1 exists")
- Provider requires authentication not provided in verification
- Response matchers too strict (exact value vs type matching)

**Solutions**:
```javascript
// Ensure consumer uses flexible matchers
const { like, eachLike, regex } = require('@pact-foundation/pact').MatchersV3;

// BAD: Exact value matching
willRespondWith: {
  status: 200,
  body: {
    id: 1,
    name: 'Alice',
    createdAt: '2025-12-06T10:00:00Z'
  }
}

// GOOD: Type matching with examples
willRespondWith: {
  status: 200,
  body: {
    id: like(1),  // Matches any integer
    name: like('Alice'),  // Matches any string
    createdAt: regex(/\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/, '2025-12-06T10:00:00Z')
  }
}

// Match state names exactly
// Consumer
state: 'user with ID 1 exists'

// Provider
stateHandlers: {
  'user with ID 1 exists': async () => { /* setup */ }
  // Note: State name must match EXACTLY (case-sensitive)
}

// Add authentication in provider verification
new Verifier({
  provider: 'UserAPI',
  providerBaseUrl: 'http://localhost:3000',
  requestFilter: (req, res, next) => {
    // Add auth header to all verification requests
    req.headers['Authorization'] = 'Bearer test-token-12345';
    next();
  },
  stateHandlers: { /* ... */ },
}).verifyProvider();
```

**Debugging Tips**:
- Compare consumer mock responses with actual provider responses
- Check Pact Broker verification logs for detailed error messages
- Run provider verification with `--verbose` flag
- Verify state name spelling/capitalization matches exactly
- Test provider endpoint manually with same request from pact file

---

### Pact Files Not Publishing to Broker

**Symptoms**: Consumer tests pass but pacts don't appear in Pact Broker

**Root Causes**:
- Pact Broker URL/credentials incorrect
- Network issues preventing upload
- Consumer version/tag not specified correctly
- Pact file not generated (missing `provider.finalize()`)
- Pact Broker disk full or database down

**Solutions**:
```javascript
// Ensure finalize() is called in consumer tests
describe('User API', () => {
  const provider = new Pact({ /* config */ });

  beforeAll(() => provider.setup());
  afterEach(() => provider.verify());
  afterAll(() => provider.finalize());  // CRITICAL: Writes pact file

  it('retrieves user', async () => {
    await provider.addInteraction({ /* ... */ });
    // Test code
  });
});

// Verify pact file was generated locally
afterAll(async () => {
  await provider.finalize();

  // Check pact file exists
  const fs = require('fs');
  const pactPath = './pacts/UserUI-UserAPI.json';
  if (fs.existsSync(pactPath)) {
    console.log('✓ Pact file generated:', pactPath);
  } else {
    console.error('✗ Pact file NOT generated');
  }
});

// Publish with error handling
const { Publisher } = require('@pact-foundation/pact');

const opts = {
  pactFilesOrDirs: ['./pacts'],
  pactBroker: process.env.PACT_BROKER_URL,
  pactBrokerToken: process.env.PACT_BROKER_TOKEN,
  consumerVersion: process.env.GIT_COMMIT || '1.0.0',
  tags: [process.env.GIT_BRANCH || 'main'],
};

try {
  await new Publisher(opts).publishPacts();
  console.log('✓ Pacts published successfully');
} catch (error) {
  console.error('✗ Pact publishing failed:', error.message);

  // Check Pact Broker connectivity
  const response = await fetch(process.env.PACT_BROKER_URL);
  console.log('Pact Broker status:', response.status, response.statusText);
}
```

**Debugging Tips**:
- Check pact files exist in `./pacts/` directory after tests
- Test Pact Broker upload manually: `pact-broker publish ./pacts --broker-base-url=... --consumer-app-version=1.0.0`
- Verify Pact Broker health: `curl https://pact-broker.example.com/diagnostic/status/heartbeat`
- Check Pact Broker logs for upload errors
- Ensure CI environment has network access to Pact Broker

---

### Can-I-Deploy Blocking Deployment Incorrectly

**Symptoms**: Deployment blocked even though contracts are compatible

**Root Causes**:
- Provider verification results not published
- Consumer version selector not matching deployed versions
- Pending pacts not enabled (provider hasn't verified new consumer contracts yet)
- Deployment environment not recorded in broker
- Stale verification results (old provider version)

**Solutions**:
```javascript
// Ensure provider publishes verification results
new Verifier({
  provider: 'UserAPI',
  providerBaseUrl: 'http://localhost:3000',
  pactBrokerUrl: process.env.PACT_BROKER_URL,
  publishVerificationResult: true,  // CRITICAL: Publish results
  providerVersion: process.env.GIT_COMMIT,
  providerVersionTags: [process.env.GIT_BRANCH],
}).verifyProvider();

// Record deployment in Pact Broker
const { execSync } = require('child_process');

// After successful deployment
execSync(`
  pact-broker record-deployment \
    --pacticipant UserAPI \
    --version ${process.env.GIT_COMMIT} \
    --environment production \
    --broker-base-url ${process.env.PACT_BROKER_URL} \
    --broker-token ${process.env.PACT_BROKER_TOKEN}
`);

// Use pending pacts in provider verification
new Verifier({
  provider: 'UserAPI',
  enablePending: true,  // Don't fail on new unverified pacts
  includeWipPactsSince: '2025-01-01',  // Include work-in-progress pacts
  consumerVersionSelectors: [
    { tag: 'main', latest: true },
    { deployedOrReleased: true },
  ],
}).verifyProvider();

// Debug can-i-deploy decision
execSync(`
  pact-broker can-i-deploy \
    --pacticipant UserAPI \
    --version ${process.env.GIT_COMMIT} \
    --to-environment production \
    --broker-base-url ${process.env.PACT_BROKER_URL} \
    --broker-token ${process.env.PACT_BROKER_TOKEN} \
    --verbose  # Show detailed decision logic
`, { stdio: 'inherit' });
```

**Debugging Tips**:
- Check verification results in Pact Broker UI
- Verify provider version matches: `pact-broker list-latest-pact-versions`
- Review consumer version selectors (ensure they match deployed versions)
- Check deployment records: `pact-broker list-deployed-versions`
- Use `--retry-while-unknown` to wait for pending verifications

---

### Contract Tests Flaky in CI

**Symptoms**: Tests pass locally but fail intermittently in CI

**Root Causes**:
- Mock provider port conflicts (multiple tests using same port)
- Test database not isolated between test runs
- Async timing issues (race conditions)
- CI environment missing required dependencies
- Network issues in CI (firewall blocking Pact Broker)

**Solutions**:
```javascript
// Use random ports to avoid conflicts
const getRandomPort = () => Math.floor(Math.random() * (9999 - 8000) + 8000);

const provider = new Pact({
  consumer: 'UserUI',
  provider: 'UserAPI',
  port: getRandomPort(),  // Random port per test suite
  log: path.resolve(process.cwd(), 'logs', `pact-${Date.now()}.log`),
});

// Isolated test database per CI job
beforeAll(async () => {
  const testDbName = `test_db_${process.env.CI_JOB_ID || Date.now()}`;
  await db.createDatabase(testDbName);
  await db.connect(testDbName);
});

afterAll(async () => {
  await db.dropDatabase();
  await db.disconnect();
});

// Add retry logic for flaky network calls
async function verifyWithRetry(verifier, maxRetries = 3) {
  for (let i = 0; i < maxRetries; i++) {
    try {
      await verifier.verifyProvider();
      return; // Success
    } catch (error) {
      console.warn(`Verification attempt ${i + 1} failed:`, error.message);

      if (i === maxRetries - 1) {
        throw error; // Final attempt failed
      }

      // Exponential backoff
      await new Promise(resolve => setTimeout(resolve, Math.pow(2, i) * 1000));
    }
  }
}

// Ensure Pact cleanup
afterAll(async () => {
  try {
    await provider.finalize();
  } catch (error) {
    console.error('Pact cleanup failed:', error);
  }
});
```

**Debugging Tips**:
- Run tests with `--verbose` to see detailed Pact logs
- Check for port conflicts: `lsof -i :1234` (macOS/Linux) or `netstat -ano | findstr :1234` (Windows)
- Verify CI has network access: `curl https://pact-broker.example.com`
- Check CI logs for timing issues (add timestamps to log statements)
- Test with same environment variables as CI: `CI_JOB_ID=test npm test`

---

### Message Pact Verification Failing

**Symptoms**: Message-based contract tests fail during provider verification

**Root Causes**:
- Message provider not generating expected message structure
- Message metadata mismatch (content-type, headers)
- Message handler not processing message correctly
- Async message handling not awaited
- Message queue not mocked properly

**Solutions**:
```javascript
// Ensure message provider returns correct structure
const { MessageProviderPact } = require('@pact-foundation/pact');

describe('Order Service Message Provider', () => {
  it('verifies message contracts', () => {
    return new MessageProviderPact({
      messageProviders: {
        'an order created event': () => {
          // Return EXACT message structure consumer expects
          return {
            eventType: 'ORDER_CREATED',
            orderId: 123,
            customerId: 456,
            total: 99.99,
            createdAt: '2025-12-06T10:00:00Z',
            // Include all fields from consumer contract
          };
        },
      },
      // Verify metadata if consumer specifies it
      messageMeta: {
        'an order created event': {
          contentType: 'application/json',
        },
      },
    }).verify();
  });
});

// Consumer handler must return promise
it('handles order created event', () => {
  return messagePact
    .expectsToReceive('an order created event')
    .withContent({ /* ... */ })
    .verify(async (message) => {
      // MUST return promise
      const handler = new OrderEventHandler();
      await handler.handleOrderCreated(message);

      // Verify handler processed message
      const order = await db.orders.findById(message.orderId);
      expect(order).toBeDefined();
    });
});
```

**Debugging Tips**:
- Compare message structure between consumer expectation and provider generation
- Check message metadata matches (content-type, encoding)
- Verify message handler is async and awaited properly
- Test message provider in isolation: call message provider function directly
- Check for missing fields in provider message (provider must return all fields consumer expects)

---

### OpenAPI Schema Validation Rejecting Valid Responses

**Symptoms**: API returns valid data but schema validation fails

**Root Causes**:
- OpenAPI spec out of sync with implementation
- Schema uses strict `additionalProperties: false`
- Type mismatches (string vs number, nullable fields)
- Date/time format mismatch
- Nested object schema errors

**Solutions**:
```javascript
// Use less strict schema validation
const userSchema = {
  type: 'object',
  properties: {
    id: { type: 'integer' },
    name: { type: 'string' },
    email: { type: 'string', format: 'email' },
    createdAt: { type: 'string', format: 'date-time' },
  },
  required: ['id', 'name', 'email'],
  additionalProperties: true,  // Allow extra fields (less strict)
};

// Handle nullable fields correctly
const userSchema = {
  properties: {
    phoneNumber: {
      type: ['string', 'null'],  // Allow null
      pattern: '^\\+?[0-9]{10,15}$',
    },
    // OR using oneOf
    address: {
      oneOf: [
        { type: 'string' },
        { type: 'null' },
      ],
    },
  },
};

// Debug validation failures
const validate = ajv.compile(userSchema);
const valid = validate(response.body);

if (!valid) {
  console.error('Schema validation errors:');
  validate.errors.forEach(error => {
    console.error(`  - ${error.dataPath}: ${error.message}`, error.params);
  });

  // Show actual vs expected
  console.log('Actual response:', JSON.stringify(response.body, null, 2));
}
```

**Debugging Tips**:
- Use AJV in verbose mode to see detailed validation errors
- Compare actual response structure with schema definition
- Check for type mismatches: `typeof response.body.id === 'number'`
- Validate OpenAPI spec itself: `openapi-validator validate openapi.yaml`
- Generate schema from TypeScript types to keep in sync: `typescript-json-schema`

---

## Quick Reference

### Pact vs Schema Validation

| Aspect | Pact (CDC) | JSON Schema / OpenAPI |
|--------|------------|----------------------|
| **Approach** | Consumer-driven | Provider-driven |
| **Focus** | Actual usage patterns | Complete API specification |
| **Setup Complexity** | Higher (broker, webhooks) | Lower (just schema files) |
| **Flexibility** | Tests only what consumers use | Tests entire API surface |
| **Bidirectional** | Yes (consumer + provider tests) | No (provider tests only) |
| **Best For** | Microservices, cross-team APIs | Public APIs, documentation |

---

### Contract Testing Checklist

**Consumer Side**:
- [ ] Consumer tests define expected interactions
- [ ] Pact files generated and published to broker
- [ ] Tests use matchers (not exact values)
- [ ] Consumer version tagged (e.g., `main`, `production`)
- [ ] Tests run on every commit

**Provider Side**:
- [ ] Provider verification tests fetch pacts from broker
- [ ] State handlers set up required data
- [ ] Verification results published to broker
- [ ] Provider version tagged with environment
- [ ] Verification triggered by pact changes (webhook)

**CI/CD Integration**:
- [ ] Consumer publishes pacts after successful tests
- [ ] Provider verifies on every build
- [ ] `can-i-deploy` blocks unsafe deployments
- [ ] Deployment recorded in broker
- [ ] Webhooks trigger cross-team builds

**Versioning**:
- [ ] API versioned semantically (MAJOR.MINOR.PATCH)
- [ ] Breaking changes increment MAJOR version
- [ ] Deprecation policy documented and enforced
- [ ] Backward compatibility maintained for N-1 versions
- [ ] Sunset dates communicated 6+ months in advance

---

### Common Pitfalls

**Pitfall 1: Testing Implementation Details**
- **Bad**: Exact value matching (`name: 'Alice'`)
- **Good**: Type matching (`name: like('Alice')`)

**Pitfall 2: Flaky State Handlers**
- **Bad**: State handler doesn't clean up previous data
- **Good**: Truncate tables before inserting test data

**Pitfall 3: Ignoring `can-i-deploy`**
- **Bad**: Deploy without checking contract verification
- **Good**: Block deployment if `can-i-deploy` fails

**Pitfall 4: Provider-First Design**
- **Bad**: Provider builds API, consumers adapt
- **Good**: Consumers define needs, provider implements

**Pitfall 5: Over-Specifying Contracts**
- **Bad**: Test every possible response field
- **Good**: Test only fields consumer actually uses

---

### Tools and Resources

**Pact Implementations**:
- **JavaScript/TypeScript**: `@pact-foundation/pact`
- **Python**: `pact-python`
- **Java**: `au.com.dius.pact`
- **Ruby**: `pact` gem
- **Go**: `pact-go`
- **.NET**: `PactNet`

**Schema Validation**:
- **AJV**: Fast JSON Schema validator (JavaScript)
- **Prism**: Mock server from OpenAPI specs
- **Dredd**: API testing against OpenAPI/Swagger
- **json-schema** (Python), **jsonschema** (Ruby)

**Pact Broker**:
- Self-hosted: `pactfoundation/pact-broker` Docker image
- SaaS: Pactflow (commercial, hosted by Pact Foundation)

**CI/CD**:
- `pact-broker` CLI: Publish pacts, can-i-deploy, record deployments
- GitHub Actions: `pactfoundation/setup-pact`
- GitLab CI, Jenkins, CircleCI integrations available

---

**Reference Version**: 1.0.0
**Last Updated**: 2025-12-04

---

## Sources

- [Introduction | Pact Docs](https://docs.pact.io/)
- [Consumer Driven Contracts with Pact | Baeldung](https://www.baeldung.com/pact-junit-consumer-driven-contracts)
- [What is Consumer-Driven Contract Testing (CDC)? | Pactflow](https://pactflow.io/what-is-consumer-driven-contract-testing/)
- [Schema-based contract testing with JSON Schema and OpenAPI](https://pactflow.io/blog/contract-testing-using-json-schemas-and-open-api-part-2/)
- [Contract testing with OpenAPI | Speakeasy](https://www.speakeasy.com/blog/contract-testing-with-openapi)
- [How API Schema Validation Boosts Effective Contract Testing | Zuplo](https://zuplo.com/blog/2025/04/15/how-api-schema-validation-boosts-effective-contract-testing)
- [Creating, evolving, and versioning microservice APIs and contracts | Microsoft Learn](https://learn.microsoft.com/en-us/dotnet/architecture/microservices/architect-microservice-container-applications/maintain-microservice-apis)
- [Best practices for versioning API contracts | Medium](https://proteinshaikh.medium.com/best-practices-for-versioning-api-contracts-to-avoid-breaking-changes-a54fbc6d469d)
- [Can I Deploy | Pact Docs](https://docs.pact.io/pact_broker/can_i_deploy)
- [CI/CD Setup Guide | Pact Docs](https://docs.pact.io/pact_nirvana)
